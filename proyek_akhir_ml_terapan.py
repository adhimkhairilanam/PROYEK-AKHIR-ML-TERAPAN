# -*- coding: utf-8 -*-
"""Proyek_Akhir_ML_Terapan.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1haZlCcSlyk2OcyFyKeTH97ViFGnpdpDU

# **1. Import Library**
Mengimpor library yang dibutuhkan untuk pengolahan data, pembuatan model, dan evaluasi.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.neighbors import NearestNeighbors
import scipy.sparse as sp

"""# **2. Memuat dan Memahami Data**
Memuat dataset preprocessed_dataset.csv untuk memahami struktur data.
"""

# Memuat dataset
anime = pd.read_csv('anime.csv')
ratings = pd.read_csv('rating.csv', nrows=500000)  # Misalnya hanya 500.000 baris

# Menampilkan 5 baris pertama dari dataset anime
print('Data Anime:')
print(anime.head())

# Menampilkan 5 baris pertama dari dataset ratings
print('\nData Rating:')
print(ratings.head())

# Informasi dataset
print('\nInfo Anime:')
print(anime.info())

print('\nInfo Ratings:')
print(ratings.info())

# Menghapus rating -1
ratings_clean = ratings[ratings['rating'] != -1]

plt.figure(figsize=(8, 6))
sns.histplot(ratings_clean['rating'], bins=10, kde=False)
plt.title('Distribusi Rating')
plt.xlabel('Rating')
plt.ylabel('Jumlah')
plt.show()

# Jumlah anime per genre
genres = anime['genre'].dropna().str.split(', ').explode()
genre_counts = genres.value_counts()

plt.figure(figsize=(12, 6))
genre_counts.plot(kind='bar')
plt.title('Jumlah Anime per Genre')
plt.xlabel('Genre')
plt.ylabel('Jumlah Anime')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""# **3. Data Preparation untuk Content-based Filtering**
Membersihkan data dan mengubah kolom genre menjadi format yang bisa digunakan untuk menghitung kemiripan.
"""

# Menghapus data dengan genre kosong
anime_clean = anime.dropna(subset=['genre'])

# Menggunakan TF-IDF Vectorizer untuk mengubah teks genre menjadi fitur numerik
tfidf = TfidfVectorizer(token_pattern=r'[^, ]+', stop_words='english')
tfidf_matrix = tfidf.fit_transform(anime_clean['genre'])

cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

# 5. Buat mapping dari judul anime ke indeks
indices = pd.Series(anime_clean.index, index=anime_clean['name']).drop_duplicates()
print("Shape of TF-IDF matrix:", tfidf_matrix.shape)

"""# **4. Implementasi Content-based Filtering**
Membuat fungsi untuk merekomendasikan anime berdasarkan kemiripan genre.
"""

def get_content_based_recommendations(title, cosine_sim=cosine_sim, anime=anime, top_n=10):

    if title not in anime['name'].values:
        return f"Anime dengan judul '{title}' tidak ditemukan."

    idx = anime[anime['name'] == title].index[0]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[1:top_n+1]
    anime_indices = [i[0] for i in sim_scores]

    return anime.iloc[anime_indices][['anime_id', 'name']]

print('Rekomendasi untuk "Naruto":')
print(get_content_based_recommendations('Naruto'))

"""# **HEATMAP COSINE SIMILARITY**"""

import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(8, 6))
sns.heatmap(cosine_sim[:10, :10], annot=True, cmap='Blues')
plt.title('Heatmap Cosine Similarity (10 Anime Pertama)')
plt.show()

"""# **5. Data Preparation untuk Collaborative Filtering**
Membuat matriks user-item berdasarkan rating dan mempersiapkan model KNN
"""

user_item_matrix = ratings.pivot(index='user_id', columns='anime_id', values='rating')
user_item_matrix = user_item_matrix.fillna(0)

sparse_matrix = sp.csr_matrix(user_item_matrix.values)

knn = NearestNeighbors(metric='cosine', algorithm='brute')
knn.fit(sparse_matrix)

print("Dimensi user-item matrix:", user_item_matrix.shape)

"""# **6. Implementasi Collaborative Filtering**
Membuat fungsi untuk merekomendasikan anime berdasarkan rating pengguna lain


"""

def get_collaborative_recommendations(user_id, user_item_matrix=user_item_matrix, knn=knn, anime=anime, top_n=10):

    user_idx = user_item_matrix.index.get_loc(user_id)

    distances, indices = knn.kneighbors(sparse_matrix[user_idx], n_neighbors=11)

    similar_users = user_item_matrix.iloc[indices.flatten()[1:]]
    anime_scores = similar_users.mean(axis=0)
    top_anime = anime_scores.sort_values(ascending=False).head(top_n)
    anime_ids = top_anime.index

    return anime[anime['anime_id'].isin(anime_ids)][['anime_id', 'name']].drop_duplicates()

print('Rekomendasi untuk user_id = 1:')
print(get_collaborative_recommendations(1))

"""# **7. Evaluasi**
Mengevaluasi hasil rekomendasi secara kualitatif:
- Evaluasi Content-Based Filtering : Mengecek apakah sistem merekomendasikan anime yang mirip secara konten (misalnya genre) dengan anime input
- Evaluasi Collaborative Filtering : Mengecek apakah anime yang direkomendasikan ke pengguna memiliki rating tinggi dari komunitas pengguna lain

**7.1 Evaluasi Content-Based Filtering**
"""

# Evaluasi Content-based Filtering
def evaluate_content_based(title, anime=anime, cosine_sim=cosine_sim, top_n=10):
    if title not in anime['name'].values:
        print(f"Anime '{title}' tidak ditemukan.")
        return

    input_idx = anime[anime['name'] == title].index[0]
    input_genres = anime.iloc[input_idx]['genre']

    # Ambil rekomendasi
    recommendations = get_content_based_recommendations(title, cosine_sim, anime, top_n)

    # Cek genre rekomendasi
    print(f"Genre anime input '{title}': {input_genres}")
    print("\nRekomendasi dan genrenya:")
    for rec_title in recommendations['name'].values:
        rec_genres = anime[anime['name'] == rec_title]['genre'].values[0]
        print(f"- {rec_title}: {rec_genres}")

# Contoh evaluasi
evaluate_content_based('Naruto')

"""**7.2 Evaluasi Collaborative Filtering**"""

# Evaluasi Collaborative Filtering
def evaluate_collaborative(user_id, user_item_matrix=user_item_matrix, knn=knn, anime=anime, ratings=ratings, top_n=10):

    recommendations = get_collaborative_recommendations(user_id, user_item_matrix, knn, anime, top_n)

    recommended_ids = recommendations['anime_id'].tolist()
    avg_ratings = ratings[ratings['anime_id'].isin(recommended_ids)].groupby('anime_id')['rating'].mean()

    print(f"Rekomendasi untuk user_id = {user_id}:")
    for i, row in recommendations.iterrows():
        anime_id = row['anime_id']
        name = row['name']
        avg_rating = avg_ratings.get(anime_id, 'Tidak ada rating')
        print(f"- {name}: Rata-rata rating = {avg_rating}")


evaluate_collaborative(1)

"""**Content-based Filtering**

Content-based Filtering berfungsi untuk mengukur seberapa relevan genre rekomendasi terhadap anime input
"""

def genre_match_percentage(title, anime=anime, cosine_sim=cosine_sim, top_n=10):
    # Cek apakah judul tersedia
    if title not in anime['name'].values:
        return f"Anime '{title}' tidak ditemukan."

    # Ambil indeks dan genre dari anime input
    input_idx = anime[anime['name'] == title].index[0]
    input_genres = set(str(anime.iloc[input_idx]['genre']).split())

    # Ambil rekomendasi berdasarkan kemiripan konten
    recommendations = get_content_based_recommendations(title, cosine_sim, anime, top_n)

    # Hitung berapa banyak rekomendasi yang memiliki genre mencakup genre input
    matches = 0
    for rec_title in recommendations['name']:
        rec_genres = set(str(anime[anime['name'] == rec_title]['genre'].values[0]).split())
        if input_genres.issubset(rec_genres):
            matches += 1

    return (matches / top_n) * 100

result = genre_match_percentage('Naruto')
print(f"Genre Match Percentage untuk 'Naruto': {result}%")